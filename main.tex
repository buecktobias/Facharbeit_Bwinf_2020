\documentclass[a4paper,12pt,arial]{scrartcl}
%encoding
%--------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%--------------------------------------

%German-specific commands
%--------------------------------------
\usepackage[ngerman]{babel}

%---------------------  packages
\usepackage{pgffor}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage{caption}
\usepackage{listings}
\usepackage{pdfpages}
%% quellen
\usepackage[defernumbers=true,style=numeric,sorting=ynt]{biblatex}

%\usepackage{biblatex}
%% in name.bib sind die Quellen
\addbibresource{name.bib}

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{scrlayer-scrpage, lastpage}
\usepackage{pdfpages}
\usepackage[a4paper,margin=2.5cm,left=3cm,footskip=0.5cm]{geometry}
\setkomafont{pageheadfoot}{\large\textrm}
\cfoot*{\thepage{}}
\usepackage{setspace}
\onehalfspacing

%%---------- Der Pfad der Grafiken
\graphicspath{ {./images/pdfs/} }



% ---------Variablen ----------------------------------
\newcommand{\Name}{Tobias Bück}
\newcommand{\Strasse}{Am Judensand 7}
\newcommand{\Ort}{Mainz}
\newcommand{\PLZ}{55122}
\newcommand{\Schule}{Gymnasium Mainz-Oberstadt}
\newcommand{\Leistungskurs}{Informatik}
\newcommand{\Betreuer}{Jorg \textsc{Schaede}}
\newcommand{\Thema}{Bundeswettbewerb Informatik 38}

%%%------ Enironments and Comands-------------------------------
\newenvironment{pseudocode}
{
\bgroup\obeylines

}
{
\egroup
}

\newenvironment{classInformation}[1]
{
    \subsubsection{#1}
    \label{sec:#1}
}
{
}

\newcommand{\addDescription}[1]{
\paragraph{Beschreibung:}
#1
}

\newenvironment{relations}
{
\textbf{Beziehungen zu anderen Klassen:}
\begin{itemize}
}
{\end{itemize}}

\newcommand{\addInheritance}[2]{
\item erbt von \textit{#1} (\ref{#2} siehe auf Seite \pageref{#2})
}

\newcommand{\hasObjects}[2]{
\item hat Objekte von {\textit{#1} (\ref{#2} siehe auf Seite \pageref{#2})}
}


\newcommand{\noAttributes}{
    \textbf{wichtige Attribute:}
    \\
    KEINE wichtigen Attribute.
}
\newcommand{\noMethods}{
    \textbf{wichtige Methoden:}
    \\
    KEINE wichtigen Methode
}

\newenvironment{classAttributes}{
    \textbf{wichtige Attribute:}
    \\
    \begin{table}[h!]
    \begin{tabular}{| p{0.15\textwidth} |p{0.15\textwidth} | p{0.15\textwidth} | p{0.5\textwidth}|}
    \hline
    Sichtbarkeit & Attribute & Typ & Erklarung \\ [0.5ex]
    \hline\hline
    }
    {
    \hline
    \end{tabular}
    \end{table}
    \\
    }

\newcommand{\addAttribute}[4]{\centering{\textbf{#1}} & \textit{#2} & #3 &  #4 \\}


\newenvironment{classMethods}
{
\textbf{wichtige Methoden:}
\\
\begin{table}[h!]
\begin{tabular}{| p{0.15\textwidth} | p{0.17\textwidth} | p{0.18\textwidth} | p{0.5\textwidth}|}
\hline
Sichtbarkeit & Methoden & Ruckgabe-Typ & Erklarung \\ [0.5ex]
\hline\hline
}
{
\hline
\end{tabular}
\end{table}
\\
}

\newcommand{\addMethod}[4]{\centering{\textbf{#1}} & \textit{#2} & #3 &  #4 \\}

%%%%%% Beginn Dokument ---------------------------------------------

\begin{document}
\begin{titlepage}
	\centering
	\includegraphics[width=0.5\textwidth]{BWinf38_image.pdf}
	\\
    \textit{\textcite{bwinfPlakat}}
	\par\vspace{1cm}
	
	{\scshape\LARGE \Schule \par}
	\vspace{1cm}
	{\scshape\Large Facharbeit im Leistungskurs \Leistungskurs\par}
	\vspace{1.5cm}
	{\huge\bfseries \Thema\par}
	\vspace{2cm}
	{\Large\itshape \Name\par}
	\small{\Strasse, \PLZ \space \Ort}
	\vfill
\par
	betreut von\par
	\Betreuer

\end{titlepage}

\begin{abstract}
Diese Arbeit handelt von der Bearbeitung des Bundeswettbewerb Informatik 38. Dabei werden Graphentheorie, Algorithmen und Datenstrukturen zur Lösung komplexer Probleme genutzt. In der ersten Aufgabe wird ein Computer-Programm entwickelt, welches das Brettspiel Stromrallye löst. Bei der 2. Aufgabe geht es darum in einem Straßennetz den Weg zu finden, der sehr schnell ist, aber auch wenige Abbiegungen beinhaltet.
\end{abstract}
\section{Inhaltsverzeichnis}
\tableofcontents
\section{Einleitung}
Beim Bundeswettbewerb Informatik 38 habe ich mich für die Bearbeitung der Aufgaben 1 und 3 entschieden, da mir diese am interessantesten erscheinen. Der Bundeswettbewerb Informatik ist ein Wettbewerb für junge Programmierer aus Deutschland. Der Wettkampf findet in Runden statt, bei dieser Arbeit geht es um die Bearbeitung der 2. Runde.
\\
In der 2.Runde werden 2 von 3 möglichen Aufgaben gelöst. Die Aufgaben sind häufig etwas kniffeliger zu lösen und das Programmieren zum Lösen der Aufgaben spielt auch eine Rolle.\\
Die ausführliche Dokumentation der Aufgaben ist beim BWinf (Bundeswettbewerb Informatik) essentiell wichtig, um in die nächste Runde zu kommen.
\section{Hauptteil}
\newpage
\subsection{Aufgabe 1}
\subsubsection{Aufgabenstellung}
Die Aufgabenstellung befindet sich im Anhang (siehe \ref{sec:aufgabenstellung} auf Seite \pageref{sec:aufgabenstellung}).\textit{\textcite{bwinfSpielfeld}}
\subsubsection{Lösungsidee}
Damit das Ziel erreicht werden kann, die Ladung aller Batterien zu verbrauchen, muss der Roboter sich zu den Batterien bewegen.
Zu jeder Batterie mit einem positiven Ladestand muss der Roboter bewegt werden.Dabei gibt es aber mehrere Batterien, zu denen der Roboter gehen kann.Von diesen Batterien kann der Roboter wieder zu mehreren anderen Batterien laufen.
\par
\subsubsection{Kürzester Weg}
Manchmal ist es sinnvoll nicht den \textbf{kürzesten Weg} zu einer anderen Batterie zu gehen.
Es kann auch vorteilhaft sein einen längeren Weg zu laufen. Dabei kann man fast alle Wege um eine \textbf{gerade Zahl verlängern} indem man hin und her läuft, eine Verlängerung um eine ungerade Zahl ist dagegen unmöglich.
Wenn man einen Weg vom Roboter zu einer Ersatz-Batterie finden will, dann sind alle anderen Ersatz-Batterien Hindernisse, welche nicht begehbar sind.
\captionsetup[figure]{name=Abb.}
\begin{wrapfigure}{l}{0.25\textwidth}
\vspace{-10pt}
    \includegraphics[width=0.25\textwidth]{shortest_w.pdf}
    \vspace{-25pt}
    \caption{Kürzester-Weg}
    \label{fig:weg}
\vspace{-30pt}
\end{wrapfigure}
\captionsetup[figure]{name=Abbildung}
In Abbildung \ref{fig:weg}  sieht man den kürzesten Weg vom Roboter zur Ersatz-Batterie mit der Ladung 2. Der kürzeste Weg ist gelb gekennzeichnet. Der Roboter kann nicht den direkten Weg gehen, da die Ersatz-Batterien 5 und 3 den Weg versperren.

\paragraph{Weg Verlängern}


In Abbildung \ref{fig:weg_verlangern} wird gezeigt, wie ein Weg verlängert werden kann. Die Zahlen zeigen, wann der Roboter dieses Feld besucht. In diesem Beispiel ist der kürzeste Weg 3 Schritte lang, wurde aber auf 5 Schritte verlängert. Der Weg kann auch weiter verlängert werden, indem noch öfter hin und her gelaufen wird.
\begin{figure}[h]
    \centering
    \includegraphics[height=0.09\textheight]{weg_verlaengern_n.pdf}
    \caption{Weg Verlangern}
    \label{fig:weg_verlangern}
\end{figure}
\par
Die \textbf{Kürzesten Wege} vom Roboter zu den anderen Batterien werden durch \textbf{Breiten Suche} \cite{cormen} herausgefunden, dies ist \textbf{A-Stern} \cite{hart} vorzuziehen, da A-Stern nur den Weg von einem Knoten zu einem anderen berechnet, die Breiten Suche findet bei einer Durchführung den kürzesten Weg zu allen anderen Knoten. Auch der \textbf{Djikstra} \cite{dijkstra} Algorithmus findet nach einer Durchführung den kürzesten Weg zu allen Knoten. \textbf{Breiten Suche} ist trotzdem die beste Wahl, da \textbf{Breiten} Suche die \textbf{Zeitkomplexität}, $E$ = Kanten $V$ = Knoten $O(E + V)$ und \textbf{Djikstra} $O(V * log(V) + E)$ (wenn Djikstra mit Fibonacci-Heap verwendet wird) hat. Somit ist die \textbf{Breiten Suche schneller als Djikstra}.

\paragraph{Der Graph}
\captionsetup[figure]{name=Abb.}
\begin{wrapfigure}{r}{0.3\textwidth}
    \includegraphics[width=0.3\textwidth]{graph_stromrallye.pdf}
    \caption{Das Stromrallye Spiel als Graph}
    \label{fig:graph_stromrallye}
    \vspace{-5pt}
\end{wrapfigure}
\captionsetup[figure]{name=Abbildung}
Man kann das Spielfeld in einen Graphen umwandeln. Die Spielfelder sind die Knoten.


Es handelt sich um einen ungerichteten, ungewichteten Graphen, alle Konten sind in beide Richtungen begehbar und haben das Gewicht 1.
Wenn man versucht den kürzesten Weg vom Roboter zu einer Batterie zu finden, sind alle anderen Batterien Hindernisse, da man eine Batterie aufnehmen muss, wenn man auf ihr Feld geht. Deswegen sind im erzeugten Graph alle Felder mit Batterien, außer der Ziel-Batterie, nicht begehbar.

In Abbildung \ref{fig:graph_stromrallye}, sind zum besseren Verständnis die Ersatzbatterien in grau gekennzeichnet, der Roboter in grün.

In unserem Graphen, wird nicht gespeichert, wie groß die Ladung der Ersatzbatterien ist, dies ist in der Grafik nur für besseres Verständnis so dargestellt.
Der Graph speichert aber, ob ein Feld (dies entspricht im Graphen einem Knoten) begehbar ist. Ersatzbatterien sind nicht begehbar, wenn man den Weg zu einer anderen Batterie finden will.

\newpage
\subsubsection{Erklärung Graph}
\begin{wrapfigure}{r}{0.5\textwidth}
    \includegraphics[width=0.5\textwidth]{graph.pdf}
    \caption{Ein Graph \textcite{wikipediaGraph}}
    \label{fig:graph}
\end{wrapfigure}
Ein Graph ist eine Datenstruktur und besteht aus Knoten und Kanten, wobei die Knoten  mit den Kanten verbunden sind.
Es werden gerichtete und ungerichtete Graphen unterschieden.
In gerichteten Graphen haben Kanten eine Richtung, in ungerichteten nicht.
Man kann von einem Knoten über eine Kante zu einem anderen Knoten kommen usw..
In einem gewichteten Graphen haben Kanten zusätzlich ein Gewicht. Dies bedeutet, das ein bestimmtes Gewicht (oder Kosten) verwendet wird um von dem einen Knoten zum anderen zu kommen.

Beispielsweise in einem U-Bahn Netz sind Stationen die Knoten. Die Kanten sind U-Bahn-Strecken, die Kosten der Kanten geben die Fahrtdauer der Strecken an..
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{u-bahn.pdf}
    \caption{Wiener U-bahn Netz \textcite{wikipediaUbahn}}
    \label{fig:u-bahn-netz}
\end{figure}



\subsubsection{Breiten Suche}


Bei der Breiten Suche startet man vom Startknoten und überprüft dann alle Kinder, bzw. Nachbarn des Startknotens, ob sie der Zielknoten (oder eines der Zielknoten) sind.
Dies wird veranschaulicht in der Abbildung .
Dies wird nun für jeden Knoten rekursiv durchgeführt.
In einem Set (Erklärung in Kapitel \ref{sec:HashSet}) wird gespeichert, welche Knoten bereits besucht worden sind und deswegen nicht nochmal besucht werden müssen.
\par
Der Algorithmus terminiert, wenn entweder Wege zu allen Zielknoten gefunden wurden oder alle Felder besucht wurden (es kann sein, dass es zu einem Zielknoten gar keinen Weg gibt).

Die Breiten Suche funktioniert nur in einem Graph ohne Kanten Kosten, bzw. alle Kanten Kosten müssen gleich sein. In unserem Fall ist diese Bedingung gegeben, deswegen können wir die Breiten Suche verwenden um den kürzesten Weg zu finden.
In unserem Graph hat jede Kante den Kosten 1, da der Roboter bei jedem Schritt eine Energieladung verbraucht.
\par
In unserem Fall kann die breiten Suche auch bereits dann abgeschlossen werden, wenn alle Felder in der Reichweite des Roboters besucht wurden.

\begin{wrapfigure}{r}{0.3\textwidth}
    \includegraphics[width=0.3\textwidth]{Stromrallye_Feld_BFS.pdf}
    \caption{Spielfeld}
    \label{fig:bfs_stromrallye}
    \vspace{-20pt}
\end{wrapfigure}
\paragraph{In Abbildung \ref{fig:bfs_stromrallye}}
 sieht man eine durchgeführte Breiten Suche für das Stromrallye Spiel. Es werden die kürzesten Wege zu allen Feldern berechnet. Der kürzeste Weg zu einem Feld wird in der Abbildung, wie auch im Programm, gefunden, indem man vom Ziel-Feld zum Start geht und zwar so, dass die Farbe der abgelaufenen Felder sich von rot->leuchtrot->dunkel orange -> orange -> gelb -> grün verändert.
\setlength{\itemsep}{-60pt}
\\
Die Anzahl der Schritte zu einem Feld sind:
\small
\begin{compactitem}
\item 1 Schritt: grün
\item 2 Schritte: gelb
\item 3 Schritte: orange
\item 4 Schritte: dunkel orange
\item 5 Schritte: Leuchtrot
\item 6 Schritte: Rot
\end{compactitem}
\tiny{ \url{https://www.ralfarbpalette.de/ral-classic/ral-3024-leuchtrot}}  , \tiny{\url{https://www.99colors.net/color-names}}
\normalsize
\subsubsection{Djikstra}
Der Djikstra Algorithmus funktioniert ähnlich wie die Breiten Suche. Zusätzlich sortiert der Djikstra Algorithmus die Knoten nach Kosten und besucht zuerst den Knoten, zu dem ein Weg mit geringsten Kosten gefunden wurde.
\\
Dies bringt in unserem Fall nichts, da alle Knoten die gleichen Kosten haben und zwar 1.  Das Sortieren der Knoten macht allerdings den Djikstra Algorithmus langsamer  als die Breiten Suche.
\subsubsection{A-Stern}
 A-Stern nutzt eine zusätzliche Heuristik , um den bestmöglichen Pfad zuerst zu verwenden.
In unserem Fall wäre so eine Heuristik, wie weit der Knoten vom Zielknoten entfernt ist. 
Im A Stern Algorithmus werden dann Knoten, die näher am Zielknoten sind, zuerst besucht.
Dies macht den A Stern Algorithmus deutlich schneller als Djikstra und Breiten Suche.
Die Breiten Suche kann man durch die Verwendung einer Heuristik nochmal stark verbessern.
Da die Wahrscheinlichkeit, dass der schnellste Weg in der Richtung des Zielorts liegt, viel höher ist, wird dies bei  A Stern clever genutzt, um den Algorithmus wesentlich schneller zu machen.

\subsubsection{Kürzester Weg-Fazit}


Die Breiten Suche ist am schnellsten, da diese mit einer Durchführung die kürzesten Wege zu allen Ziel-Knoten findet und außerdem keine zusätzliche Zeit durch Sortieren der Knoten verbraucht.



\par

\subsubsection{Kürzester Weg - Laufzeitanalyse}
In unserem ungerichteten Graphen ist der Weg von A nach B genauso lang und hat genau die gleichen Stationen (in umgekehrter Reihenfolge) wie der Weg von B nach A.
Damit die Breiten Suche nicht immer wieder neu ausgeführt wird, speichern wir unsere vorherigen Ergebnisse in einer HashMap. 
Der kürzeste Weg wird immer vom Roboter zu den Ersatzbatterien berechnet und er wird nur dann berechnet, wenn der Roboter auf einer Ersatzbatterie steht oder bei der Startposition.
Es gibt so viele Zielorte wie die \textbf{Anzahl-Ersatzbatterien}, außer wenn der Roboter sich beim Start schon auf einer Ersatzbatterie befindet, dann einer weniger.
Also wenn e die Anzahl der Ersatzbatterien ist, dann werden maximal
\begin{align*}
    \sum_{n=0}^{e} n
\end{align*}

viele Wege berechnet.
Bei der Ausführung von Breiten Suche werden direkt von einem Start Wege zu allen Zielen gefunden. Deswegen muss die Breiten Suche maximal $e-1$ oft ausgeführt werden. Da die Breiten Suche $O(E+V)$ lange dauert, kommen wir so auf eine worst-case Laufzeitkomplexität von $O(e * (E + V))$.

\subsubsection{Der Weg zu sich selbst}
\begin{wrapfigure}{r}{0.3\textwidth}
    \centering
    \includegraphics[width=0.3\textwidth]{way_to_self.pdf}
    \caption{Weg zu sich selbst}
    \label{fig:way_to_self}
\end{wrapfigure}

Von einer Ersatzbatterie kann es auch Sinn machen wieder zu sich selbst zu laufen, wobei der Weg zu sich selbst immer 2 Schritte lang ist. Es kann aber auch sein, dass es keinen Weg zu sich selbst gibt.

\newpage

\subsubsection{Der Weg ins Nichts}
\captionsetup[figure]{name=Abb.}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{way_ins_nothing.pdf}
    \caption{Weg ins nichts! Benutzung der ganzen Batterie-Ladung}
    \label{fig:way_to_nothing}
\end{figure}
\captionsetup[figure]{name=Abbildung}

Wenn alle Batterie-Ladungen 0 sind, nur der Roboter noch Ladung hat, muss dieser seine Ladung verlieren, indem er weitere Schritte läuft. Es kann aber vorkommen, dass dies nicht funktioniert, da alle Wege von anderen Batterien versperrt sind. Deswegen muss dies überprüft werden.

\subsubsection{Ersatzbatterien}

Der \textbf{Roboter} kann von einer Position mit einem bestimmten Ladestand unterschiedliche Ersatzbatterien erreichen. Nachdem der Roboter zu einer dieser Ersatzbatterien gelaufen ist, kann dieser von dort wieder zu verschiedenen Ersatzbatterien laufen.
\par
Wie bereits beschrieben, kann es aber auch Sinn machen, dass der Roboter nicht den kürzesten Weg zu einer Ersatzbatterie geht. Da ein Weg immer um eine gerade Zahl verlängert werden kann, müssen diese Möglichkeiten auch durchgegangen werden.
Also wenn der kürzeste Weg $w$ lang ist und der Roboter $b$
\\
x(1) = w \\
x(n) = x(n-1) + 2  {w + 2n < b}\\
Batterieladung hat, dann sind $(a(n)  = min(w + 2n, b))$ $n >= 0$ mögliche Weglängen.
So gibt es vom Roboter zu einer Ersatzbatterie $(b - w) / 2$ mögliche Weglängen.
\\
Zum Beispiel:
Wenn der Roboter mindestens 5 Schritte zu einer Batterie braucht und gerade 9 Ladung hat, dann sind 5, 7, 9 mögliche Anzahl Schritte um zur Batterie zu kommen.
\\
Der kürzeste Weg ist 5 Schritte lang und der Roboter hat die Batterie-Ladung 9. Da der Weg um eine gerade Zahl verlängert werden kann, sind auch 7 und 9 möglich.

\subsubsection{Möglichkeiten}

Diese \textbf{Möglichkeiten} des Roboters werden in einem \textbf{Baum} gespeichert.
Dabei werden in den \textbf{Knoten} der Spielstand (Position und Ladestand der Ersatzbatterien und des Roboters) und in den \textbf{Kanten} die Schritte und Anzahl an Schritten, welche der Roboter laufen muss, um den Spielstand $a$ zu Spielstand $b$ zu verändern, angegeben.
Dabei ist Spielstand $b$ auch wieder ein Spiel welches gelöst werden kann.
\\
Um von Spielstand $a$ zu Spielstand $b$ zu kommen, muss der Roboter eine Schrittabfolge laufen.
Der Lösungsspielstand, besteht aus einem leeren Roboter und leeren Batterien.

\par
\subsubsection{Baum}
Ein Baum ist eine Art von Graph in welchem ein Knoten Kinder hat. Diese Kinder sind untereinander nicht verbunden.
Knoten haben immer nur einen Eltern-Knoten. Der Eltern-Knoten muss eine Ebene oben drüber sein. Die Kinder eines Knotens sind immer eine Ebene unten drunter.


\subsubsection{Möglichkeiten-Baum}
Um nun herauszufinden, ob es eine Lösung gibt und welche diese ist, wird der Weg mit der größten Anzahl an Schritten gesucht. Wenn die Anzahl der Schritte der Summe der Batterieladungen (der Ersatzbatterien und des Roboters) entspricht, ist dies eine korrekte Lösung um den Ladestand aller Batterien auf 0 zu bringen.
Abbildung:
Lösung mit grün markiert
    RU : Batterie rechts unten auf dem Spiel
    RO: Batterie rechts oben auf dem Spiel
    LO: Batterie links oben
    RS: Roboters Startposition
\par
\newpage

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.6\textwidth]{rotated_baum_yeah.jpg}
    \caption{Schaubild des Moglichkeiten-Baums
    }
    \label{fig:moeglichkeiten_baum}
\end{figure}

\newpage

\subsubsection{Insgesamte Laufzeitanalyse}
Größen sind:
\begin{itemize}
    \item Größe des Spielfelds
    \item Anzahl Batterien
    \item Summe der Ladungen an Batterien
\end{itemize}

Die Laufzeit meines Algorithmus ist von all diesen genannten Größen abhängig.
Je größer das Spielfeld, je mehr Batterien und je mehr Ladung, desto länger braucht mein Programm.
Desto mehr Batterien, desto Länger braucht der Algorithmus.
Desto mehr Ladung, desto länger braucht mein Programm.
\par
Am abhängigsten ist mein Algorithmus, aber von der Anzahl an Batterien, da sich dadurch der Möglichkeiten-Baum sehr stark vergrößert, weil dann die Zahl an Knoten zunimmt.
\par
Der worst-case für meinen Algorithmus ist, dass sich auf jedem Feld des Spielfelds eine Batterie befindet, mit der Ladung 1. Dies führt zu einer Zeitkomplexität von $O(4)^L$; wenn $L$ die Gesamt Summe der Batterien ist, welche dann äquivalent zur Anzahl Felder ist, also der quadrierten Größe. Daher gilt auch $O(4^(s*s))$; $s$für size entspricht der Größe des Spielfelds.
Die 4, weil es 4 Richtungen gibt, in welche sich der Roboter bewegen kann.
\par
Die Zeit für das Berechnen der kürzesten Wege fällt bei Spielen mit vielen Batterien nicht so stark ins Gewicht.\par
Die Breiten Suche braucht $O(e * (E + V))$, $e$ Anzahl Ersatzbatterien, $E$ Edges, $V$ gleich Vertices. Jeder Knoten hat maximal 4 Kanten (bzw. Nachbarn), also $O(E) = O(V)$, $O(e * (E+V)) = O(e * V)$. In unserem worst-case Szenario, beschrieben im vorherigen Absatz, entspricht die Anzahl der Knoten, der Anzahl an Feldern, also $e=s*s$; $s$ für size ist die Größe des Spielfelds.
$V$ wiederum entspricht ebenfalls $s*s$. Daher kommen wir insgesamt auf $O(s*s*s*s)$,
also $O(s^4)$. Da $e$ = $s * s$. Können wir auch sagen $O(e^2)$. Also ist die Laufzeit der Breiten Suche quadratisch zur Anzahl Batterien.
Die Laufzeit für den Möglichkeiten-Baum ist wesentlich größer.
Sie ist $O(4^(s*s))$ oder $O(4^e)$.
Beide Laufzeiten addiert: $O(4^e) + O(e^2)$ = $O(4^e)$
\textbf{Die insgesamte worst-case Laufzeit ist:}
\begin{itemize}
\item In Abhängigkeit der Anzahl Batterien($e$) => \texttt{$O(4^e)$}
\item In Abhängigkeit der Größe des Spielfelds($s$) => \texttt{$O(4^(s*s))$}
\item In Abhängigkeit der Größe< des Spielfelds($L$) => \texttt{$O(4^L)$}
\end{itemize}
\subsubsection{Umsetzung}
Der Algorithmus wird in Python (Version 3.7) implementiert.


\newpage
\subsubsection{UML-Klassen-Diagramm}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{uml_diagramm_v5.png}
    \caption{UML Klassen Diagramm}
    \label{fig:uml}
\end{figure}
\newpage

\newpage
\subsubsection{Losungen}


Eingabe:
\texttt{ \\
5 \\
3,5,9 \\
3 \\
5,1,3 \\
1,2,2 \\
5,4,3 \\
}
\par
Erklärung:

Die Dateien enthalten jeweils ein Spielbrett mit den darauf verteilten Batterien und dem Roboter.

In der ersten Zeile ist Grö?e des Spielbretts angegeben, in der zweiten Zeile sind die Koordinaten des Roboters und die Ladung seiner Batterie und in der dritten Zeile ist die Anzahl der restlichen auf dem Spielbrett verteilten Batterien angegeben.
Ab der vierten Zeile ist in jeder Zeile eine Batterie angegeben, also ihre Koordinaten und ihre Ladung.
Dabei sind die Angaben zu den Koordinaten und der Ladung der Batterien und des Roboters als drei kommagetrennte Werte in der Form "x,y,ladung" geschrieben.
\textcite{bwinfMaterial}.

\begin{wrapfigure}{l}{0.4\textwidth}    
    \includegraphics[width=0.4\textwidth]{Solution.pdf}
    \caption{Die Lösung des Stromrallye-Spiels}
    \label{fig:loesung1} 
\end{wrapfigure}

In Abbildung \ref{fig:loesung1} sieht man die Lösung des BWinf Stromrallye Spiels. Die Zahl 9 mit dem grünen Kreis drumherum ist der Roboter, mit der Ladung 9.
Die Ersatzbatterien, sind die Fett gedruckten Zahlen in der Mitte der Felder, die Zahl zeigt die Ladung der Ersatzbatterien, beim Start an.
Die Ladung des Roboters und der Ersatzbatterien verändert sich während des Spiels, deswegen ist dies bloß eine Momentaufnahme beim Start des Spiels.
Die kleinen Zahlen im oberen Bereich der Spielfelder zeigen die Lösungsschritte.
Eine Zahl $x$ bedeutet, dass dieses Spielfeld beim $x$ten Schritt vom Roboter besucht wird.
Felder, welche keine Zahlen haben, werden nie besucht.
\\
Diese Darstellungsform habe ich gewählt, da diese noch bei sehr komplexen Spielen leicht verständlich ist und diese von einem Programm einfach generierbar sind.
\par
Weitere Lösungen befinden sich im Anhang.

\subsection{Aufgabe 1 Teil 2}
\subsubsection{Beschreibung}
Bei Teil 2 der Aufgabe 1 soll man selbst Stromrallye Spiele erstellen, welche lösbar sind, aber für einen Menschen schwer zu lösen.
(Siehe die Aufgabenstellung \ref{sec:aufgabenstellung} auf Seite\pageref{sec:aufgabenstellung})
\subsubsection{Lösungsidee}
Es werden zufällig Spielfelder generiert und dann mit dem Programm aus Aufgabe 1 geprüft, ob diese lösbar sind. Dabei werden an zufälligen Positionen Ersatz-Batterien mit einer zufälligen Ladung platziert. Die Position und die Ladung, des Roboters wird auch zufällig gewählt.
Die Größe des Spielfeld ist ebenfalls zufällig.
\subsubsection{Schwierigkeit des Spiels}
Das Spiel wird mit mehr Batterien deutlich schwerer zu lösen, auch ein größeres Spielfeld  macht es schwieriger.
\subsubsection{Lösung}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{aufgabe1_2_solution.png}
    \caption{Ein generisiertes Strom-Rallye Spiel}
    \label{fig:loesung2}
\end{figure}
\newpage
\subsection{Umsetzung}
Die Implementierung ist wie in Aufgabe 1 Teil 1 in Python. Aus dem Grund, dass ich den Algorithmus aus Teil 1 nutze, habe ich nur eine Klasse benötigt und zwar \textbf{PlayingFieldGenerator}
\paragraph{PlayingFieldGenerator}
\addDescription{Die PlayingFieldGenerator- Klasse ist die einzige Klasse, des 2.Teils. Diese erzeugt ein zufälliges, lösbares Stromrallye Spiel}
\begin{classAttributes}
\addAttribute{-}{playing\_-field\_builder}{PlayingFieldBuilder}{baut das Spielfeld}
\addAttribute{-}{positions\_used}{HashSet[Position]}{Speichert alle Positionen an welchen bereits ein Objekt ist, damit nicht zwei Objekte an einem Ort sind. Das HashSet eignet sich dafür, da es nur $O(1)$ Zeit benötigt.}
\end{classAttributes}

\begin{classMethods}
\addMethod{+}{create\_-solveable\_-playing\_field}{PlayingField}{Die Methode erzeugt ein lösbares Spielfeld}
\end{classMethods}

\subsection{Aufgabe 3}
\subsubsection{Aufgabenstellung}
Siehe im Anhang \ref{sec:aufgabenstellung} auf der Seite \pageref{sec:aufgabenstellung}.

\subsubsection{Lösungsidee}
Als erstes wandele ich das Straßennetz in einen Graphen um.
Dabei wird eine Kreuzung zu einem Knoten in dem erstellten Graphen.
Eine Straße wird zu einer Kante in dem Graphen.
Die Länge des Weges werden die Kosten der Kante.


%%% da muss noch viel gemacht werden!!!
\begin{wrapfigure}{r}{200pt}
    \includegraphics[width=0.3\textwidth]{aufgabe3.pdf}
    \caption{Straßennetz, rot ist der Weg mit den wenigsten Abkürzungen}
    \label{fig:abbiegen}
\end{wrapfigure}

\par
Dann finde ich in diesem Graphen alle möglichen Wege vom Start zum Ziel.
Nur Wege ohne Zyklen, also nur Wege welche einen Knoten maximal 1 mal besuchen. Da Wege welche einen Knoten mehrmals besuchen, langer sein müssen.
Es macht nie Sinn für Bilal einen Knoten doppelt zu besuchen.
Außerdem wurde es sonst unendliche viele mögliche Wege geben, was es unlösbar machen wurde.

\begin{wrapfigure}{l}{0.3\textwidth}
    \centering
    \includegraphics[width=0.3\textwidth]{small_example_graph.pdf}
    \caption{Graph}
    \label{fig:abbiegen}
\end{wrapfigure}
\par
Es gibt von A nach D, die möglichen Wege A -> B -> D und A -> C -> D.


\par
Um alle möglichen Wege zu finden. Verwende ich die Tiefen Suche, von jedem mit Tiefen Suche gefundenen Knoten wird wieder tiefen Suche ausgeführt.
Wenn man auf einen Knoten stößt, welcher das Ziel ist oder schon besucht wurde wird abgebrochen.
\newpage
\par
Algorithmus:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{PAP_find_path.pdf}
    \caption{Programmablaufplan um den besten Weg zu finden}
    \label{fig:pap3}
\end{figure}

\newpage
\subsubsection{Abbiegungen finden}
Wenn man vom Knoten $k$ zum Knoten $k'$ geht und beide eine Position im 2-dimensionalen Raum haben, $kp$ und $kp'$, respektiv.
Dann bewegt man sich in Richtung $kp'-kp$ wenn man sich von  $k$ zu $k'$ bewegt. Also bewegt man sich in Richtung des Richtungsvektors $r$. Wenn man nun von $k'$ zu $k''$ geht, in Richtung $r'$.
Ist dies ein Abbiegen, wenn $r != r'$.
Durch diese Definition ist auch denkbar, die Aufgabe für ein Straßennetz durchzuführen in welchem, es kompliziertere Kreuzungen gibt.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{AbbiegenBWinf.png}
    \caption{}
    \label{fig:abbiegen}
\end{figure}


Die $visited_nodes$ \ref{fig:pap3}, sind ein unsortiertes HashSet (Erklärung in Kapitel \ref{sec:HashSet}) , da dieses konstante Zeit braucht um ein Element zu suchen(herauszufinden ob es existiert) und um ein Element hinzuzufügen.
Dieses speichert keine Duplikate, was auch perfekt für uns passt, da jeder Knoten nur maximal einmal besucht werden soll.
\par
Daraufhin sortiere ich alle Wege nach der Lange des Weges. So können mit binäre Suche sehr schnell alle Wege gefunden werden, welche kurz genug sind. Nun bestimme ich mit linearer Suche, den Weg mit den wenigsten Abkürzungen.
\subsubsection{HashSet}\label{sec:HashSet}
Ein HashSet speichert eine Menge an Daten. Dabei hat es die besondere Eigenschaft, dass es keine Duplikate speichert, jedes Element ist entweder einmal oder keinmal drinnen.

Zur Implementierung wird intern ein Array gespeichert. für jedes neu eingefugt Element, wird in das Array, an der Stelle des Hashwertes  $True$ eingetragen.
Der Hashwert eines Elements wird mit Hilfe einer Hashfunktion ermittelt.

Um zu prufen ob ein Element im HashSet ist, wird die gleiche Hashfunktion wie beim eintragen verwendet. Nun wird nachgeschaut, ob an dieser Stelle True oder False. Wenn True, dann ist dieses Element enthalten, wenn False dann nicht. Um ein lLement zu löschen, wird der Wert im Array auf False gesetzt.

Auf Grund dieser Implementierung, ist das HashSet unsortiert.

Der Vorteil gegenüber einer Liste besteht darin, dass es nur $O(1)$ Zeit benötigt um zu prüfen ob ein Element enthalten ist, sowie $O(1)$, um ein Element hinzuzufügen.

\subsubsection{Besten Pfade speichern}
Speichern der besten Pfade zu jedem Knoten(Kreuzung) in einer HashMap.
Am Anfang, kennen wir nur den Weg zum Startknoten.
Nun updaten wir für alle Nachbarn des Startknoten die Map Eintrage. Dann von diesen Nacharn wieder ... und so weiter.
Ein Knoten wird nur "betrachtet", wenn ein besserer Weg zu ihm gefunden wurde. So das er weniger Abbiegungen hat oder schneller ist.
\subsubsection{HashMap}
Eine HashMap speichert key-value Paare.
Man kann für einen Schlüssel(key) einen entsprechenden Wert finden.
Neue Key value Paare können in die HashMap einzutragen.

Die HashMap Implementierung, funktioniert folgendermasen. Es wird ein Array erzeugt.
Nun wird für einen neu eingefugten Key Value Paar. Der Hashwert des Keys mit einer Hashfunktion ermittelt, am entsprechenden Index des Hashwertes, wird nun der Value eingetragen.

Um in einer Hashmap um für einen Schlüssel einen Wert zu finden wird nur konstante Zeit benötigt, genauso wie ein Wert-Schlüssel Paar einzufügen.


\subsubsection{Zielführenden Pfade zuerst}
In einer Priority Queue (Binary Heap), die zielführendsten Pfade speichern, die am nähesten am Ziel dran sind, bis jetzt den Weg mit den wenigsten Abbiegungen haben.
Aus dieser Priority Queue immer das nächste Element hinaus nehmen und für dieses die Wege zu den Nachbarn updaten. Neu gefundene Pfade in die Priority Queue einfugen.

\subsubsection{Priority Queue Binary Heap}
In einer Priority QUeue wird eine Menge an Elementen gespeichert. Dabei wird für jedes Element auch eine Priorität gespeichert.
Die Piority Queue, besitzt die Funktion, das Element mit der geringsten oder maximalen Priorität zurück zugeben. Je nachdem, ob es eine Min-Heap oder Max-Heap ist.
für Priority Queues, gibt es verschiedene Implementierungen. Unter Anderem auch die Linked-List, aber dabei ist die Performance nicht sonderbar gut. Da es O(n) Zeit braucht um das kleinste Element zu finden.
\textcite{skienaPriorityQueue}

Die Implementierung, welche ich gewählt habe ist die Binary Heap, da in diese sehr schnell neue Elemente eingefugt werden und auch das kleinste Element gefunden werden kann.

\subsubsection{Binary Heap}
Die Binary Heap, ist ein Binary Tree, mit ein paar Beschränkungen.
Also jeder Knoten hat bis zu 2 Kind Knoten.
Anders als beim Tree, ist bei der Heap, der Eltern Knoten immer kleiner als die Kind Knoten.
Neue Knoten werden in der tiefsten Ebene möglichst weit links eingefugt.


\subsubsection{Frühzeitiges Abbrechen}
Abbrechen, wenn der Ziel-Knoten, einer der Nachbar-Knoten ist. Dann macht es nur Sinn den Ziel-Knoten zu besuchen.

\subsubsection{Besten Weg speichern}
Wenn ein Weg schlechter ist, als der beste Weg zum Ziel, bzw. wenn der beste Weg, welcher von einem Knoten zum Ziel gefunden werden kann, schlechter ist als der bis jetzt beste Weg zum Ziel-Knoten, dann braucht man diesen Knoten nicht weiter zu verfolgen, sondern kann diesen löschen.

 
\subsubsection{Analyse}
Vom ersten Knoten werden neue Knoten zu allen Nachbar Knoten gefunden, von diesen wieder zu den Nachbar Knoten, ein Knoten wird aber nur besucht wenn ein besserer Knoten zu ihm gefunden wurde. Da die besseren Knoten durch die Priority Queue zuerst besucht werden und diese dann für Knoten schnell sehr gute Wege finden. Werden viele Knoten nicht oft besucht werden. Ein Knoten kann bessere Wege zu den Nachbarn finden, diese können den Knoten nicht nochmal besuchen, da sie an diesem schon waren.

\section{Fazit}
\section{Anhang}
\subsection{Offizielle Aufgaben Beschreibung des BWinf}

%\begin{figure}[h!]
%    \centering
%    \caption{Schaubild des Spielfelds mit Breiten Suche berechnete kürzeste Wege. grün: 1 Schritt, gelb: 2 Schritte -> \textcite{bwinfSpielfeld}}
%    \label{fig:bfs_stromrallye}
%\end{figure}

\label{sec:aufgabenstellung}
\includepdf[pages={4,6}]{aufgaben382.pdf}

\subsection{Programm Erklärung Aufgabe 1}
\begin{classInformation}{SolutionTree}
\addDescription{
Der \textit{SolutionTree} löst ein Spielfeld,
er speichert die \textit{root\_node} (siehe \ref{sec:Node} auf Seite \pageref{sec:Node}.)
Diese \textit{root\_node} hat wiederum Kind-Knoten, welche auch wieder Kind-Knoten haben usw. .
Mit der Funktion \textit{find\_solution} wird eine Lösung für das entsprechende Spielfeld (das Spielfeld wird nicht im \textit{SolutionTree} selbst gespeichert, aber in der \textit{root\_node} ) gefunden, falls eine existiert.}

\begin{relations}
\hasObjects{Node}{sec:Node}
\end{relations}


\begin{classAttributes}
\addAttribute{-}{root\_node}{Node}{Die \textit{root\_node} ist der oberste Knoten im \textit{SolutionTree}, sie hat selbst wieder Kind-Knoten welche wieder Kind-Knoten haben usw.}
\end{classAttributes}

\begin{classMethods}
\addMethod{+}{find\_solution()}{Optional[Path]}{Die \textit{find\_solution} Methode findet einen Pfad, welcher das Spielfeld, der \textit{root\_node} löst, falls es lösbar ist.}
\end{classMethods}
\end{classInformation}

\begin{classInformation}{Node}
\addDescription{Die \textit{Node}-Klasse ist Teil des \textit{Solution Tree} (siehe \ref{sec:SolutionTree} auf Seite \pageref{sec:SolutionTree}) . Außerdem speichert sie einen Spielstand des Stromrallye. Die \textit{Node} hat Kanten zu allen möglichen Knoten mit Spielständen, welche durch das Bewegen vom Roboter zu einer Ersatzbatterie möglich sind.}
\begin{relations}
\item ist Teil vom \textit{SolutionTree} (siehe \ref{sec:SolutionTree} auf Seite \pageref{sec:SolutionTree})
\hasObjects{Edge}{sec:Edge}
\hasObjects{PlayingField}{sec:PlayingField}
\end{relations}
\newpage
\begin{classAttributes}
\addAttribute{-}{edges}{List[Edge]}{Die \textit{edges} sind die Kanten zu den Kind-Knoten der \textit{Node} (siehe \ref{sec:Edge} auf Seite \pageref{sec:Edge})}.
\addAttribute{-}{playing\_field}{PlayingField}{Das \textit{playing\_field} ist der Spielstand dieses Knotens.}
\end{classAttributes}


\begin{classMethods}
\addMethod{+}{solve()}{None}
{
Die \textit{solve()} Funktion, löst den Spielstand des Knotens (\textit{playing\_field}). Dabei ruft die \textit{solve} Funktion rekursiv, wieder solve für alle Kind-Knoten des Knotens auf (siehe Pseudocode).
}
\end{classMethods}
\begin{pseudocode}
SOLVE(NODE):
    paths = getPathsToSpareBatteries()
    for i=0 to paths.length:
        newNode = Node()
        NODE.addEdge(Edge(NODE, newNode, paths[i]))
        SOLVE(newNode)
\end{pseudocode}
\end{classInformation}


\begin{classInformation}{Edge}
\addDescription{Die \textit{Edge} Klasse ist die Kante welche Knoten im \textit{SolutionTree}(siehe \ref{sec:SolutionTree} auf Seite \pageref{sec:SolutionTree}) miteinander verbindet.
Es wird der Pfad gespeichert, welcher der Roboter laufen muss um den Zustand des Spielfelds von Eltern- zu Kind-Knoten zu verändern.}
\begin{relations}
\item ist Teil des \textit{SolutionTrees}
\hasObjects{Node}{sec:Node}
\hasObjects{Path}{sec:Path}
\end{relations}

\begin{classAttributes}
\addAttribute{-}{path}{Path}{Die \textit{path}-Variable, gibt an, welcher Pfad der Roboter gehen muss um den Zustand des Spielfelds vom Eltern-Knotens-Spielstand zum Kind-Knotens-Spielstand zu verändern.}
\addAttribute{-}{parent\_node}{Node}{Die \textit{parent\_node}  speichert den Eltern-Knoten}
\addAttribute{-}{child\_node}{Node}{Die \textit{child\_node}  speichert den Kind-Knoten}
\end{classAttributes}
\noMethods
\end{classInformation}

\begin{classInformation}{Entity}


\addDescription{
Die \textit{Entity} Klasse, beinhaltet alle Dinge, welche Roboter und Ersatzbatterie gemeinsam haben.
Roboter und Ersatzbatterie erben beide von Entity.
Beide haben eine Position und einen Ladestand.
}
\begin{classAttributes}
\addAttribute{-}{position}{Position}{Die \textit{position} gibt die Position der Entity auf dem Spielfeld an}
\addAttribute{-}{battery\_-loading}{int}{Der aktuelle Batterie-Ladestand der Batterie}
\end{classAttributes}
\noMethods
\end{classInformation}

\begin{classInformation}{Position}
\addDescription{Die \textbf{Position} Klasse, speichert die Position der entitys (Roboter, Ersatzbatterien).
Da wir uns im 2-dimensionalen Raum befinden, besteht die Position aus x und y Koordinate, welche Attribute der Position Klasse sind.\\
Dabei habe ich ein Kordinatensystem gewählt, indem %TODO
oben links ist.
Nach unten steigt y, nach rechts steigt x.
Die Positions Klasse könnte man auch als Vektor bezeichnen.
Sie implementiert die gängigsten Vektor-Funktionen, darunter (plus, minus, Länge des Vektors, Multiplikation ...)  

}

\begin{classAttributes}
\addAttribute{-}{x}{int}{Die x-Koordinate der Position.}
\addAttribute{-}{y}{int}{Die y-Koordinate der Position.}
\end{classAttributes}

\begin{classMethods}
\addMethod{+}{manhattan\_-distance(other\_position)}{int}{manhattan distanz zur anderen Position. Die Manhattan Distanz wird folgendermaßen berechnet, $|x1 - x2| + |y1 - y2|$.
}
\end{classMethods}

\end{classInformation}

\begin{classInformation}{Roboter}
\addDescription{Der Roboter erbt von der Entity Klasse.
Zusätzlich hat der Roboter aber noch Methoden um sich zu bewegen und um seine Batterie mit einer Ersatzbatterie auszutauschen.}
\\
\textbf{wichtige Attribute:}
\\
erbt die Attribute \textit{position} und \textit{battery\_loading} von \textit{Entity}

\begin{classMethods}
\addMethod{+}{move(direction)}{None}{Der Roboter kann sich bewegen.}
\addMethod{-}{change\_-battery()}{None}{Der Roboter wechselt die Batterie, mit der unter sich liegenden Ersatzbatterie. Die Methode ist \textit{privat} und wird vom Roboter aufgerufen, wenn er sich auf ein Feld mit einer Ersatzbatterie bewegt.}
\end{classMethods}
\end{classInformation}
\newpage
\begin{classInformation}{Enum-Directions}
\addDescription{Das Enum Description, gibt die vier Richtungen (oben, unten, rechts, links) an, in welche sich der Roboter auf dem Stromrallye-Spielfeld bewegen kann.}
Die 4 verschiedenen Werte, welcher das Enum Directions haben kann sind:
\textbf{Directions.UP}\\
\textbf{Directions.DOWN}\\
\textbf{Directions.LEFT}\\
\textbf{Directions.RIGHT}\\

\begin{classMethods}
\addMethod{+}{get\_direction\_-vector()}{Position}{Die Methode getdirectionvector gibt, den entsprechenden Richtungsvektor der Richtung zurück- UP => (0, -1)- DOWN => (0, 1)- RIGHT => (1, 0) - LEFT => (-1, 0).
In diesem Fall ist unsere Positions-Klasse, der Richtungsvektor
}
\end{classMethods}
\end{classInformation}
\begin{classInformation}{SpareBatterie}
\addDescription{Die Ersatzbatterie (SpareBattery) erbt von der Entity-Klasse. Da sie sich nicht bewegen kann und auch sonst nichts machen kann, hat diese keine besonderen Attribute oder Funktionen.}

\textbf{wichtige Attribute:}\\
erbt \textit{position}und \textit{battery\_loading} von \textit{Entity}
\noMethods
\end{classInformation}

\begin{classInformation}{Spielfeld}
\addDescription{Die Spielfeld Klasse beinhaltet alle Objekte des Spiels. Sie speichert die Elemente des Spiels. Außerdem auch das Spielfeld als Graphen. Sie hat eine Größe, da sie quadratisch ist, wird nicht zwischen Länge und Breite unterschieden.
}
\newpage
\begin{classAttributes}
\addAttribute{-}{size}{int}{Die Größe des Spielfelds}
\addAttribute{-}{game\_objects}{List[Entity]}{Die Liste aller Objekte, die auf dem Spielfeld sind.}

\end{classAttributes}
\begin{classMethods}
\addMethod{+}{get\_shortest\_-path(-from:Position, to:Position)}{Path}{Findet den kürzesten Weg auf dem Spielfeld von einer Position zu einer anderen, ohne andere Ersatzbatterien aufzusammeln außer des Ziels.}
\end{classMethods}

\end{classInformation}

\begin{classInformation}{Graph}
\addDescription{Die Graph Klasse, entspricht einem normalen Graphen in der Informatik. Es ist ein ungerichteter, ungewichteter Graph, weswegen es auch keine Kanten als Objekte gibt, auch keine Klasse, da alle Kanten Kosten 0 haben.
Stattdessen speichert jeder Knoten(Vertex), die Nachbar Knoten(Vertices).
Der Graph speichert alle Knoten in einer Liste.}

\begin{classAttributes}
\addAttribute{-}{vertices}{HashMap-[Position,- Vertex]}{Alle Knoten des Graphen werden in der HashMap \textit{vertices} gespeichert. Es wird eine HashMap verwendet, da man bei solcher nur konstante Zeit O(1) benötigt um ein Knoten an einem Punkt zu bekommen. Eine weitere Alternative ist ein 2-dimensionales Array, bei dem an Stelle vertices[x][y] -> der Knoten der Position x y ist.}
\end{classAttributes}
\begin{classMethods}
\addMethod{+}{bfs(from, to)}{HashMap[Vertex, Path]}{Führt die breiten Suche (engl. \textbf{b}readth \textbf{f}irst \textbf{s}earch) aus.}
\end{classMethods}
\end{classInformation}

\begin{classInformation}{Vertex}
\addDescription{Die Vertex-Klasse, ist ein Knoten des Graphen. Der Knoten kennt seine Nachbar Knoten und hat eine Position.}
\begin{classAttributes}
\addAttribute{-}{position}{Position}{Position auf dem Spielfeld.}
\addAttribute{-}{neighbours}{List[Vertex]}{Nachbarknoten}
\end{classAttributes}
\begin{classMethods}
\addAttribute{+}{add\_neighbour}{None}{Fügt einen Knoten als Nachbar hinzu.}
\end{classMethods}
\end{classInformation}


\subsection{Beispiel3}
\subsubsection{Eingabe}
\texttt{ \\
14 \\
3,5,9 \\
3 \\
6,4,4 \\
5,12,10 \\
6,2,5 \\
}
\subsubsection{Lösung}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{solution3.pdf}
    \caption{Losung des BWinfs Stromrallye Spiels Beispiel 3}
    \label{fig:loesung3}
\end{figure}

\subsection{Beispiel4}
\subsubsection{Eingabe}
\texttt{ \\
100 \\
40,25,20 \\
0 \\
}
\subsubsection{Losung}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{solution4.png}
    \caption{Losung des BWinfs Stromrallye Spiels Beispiel 4}
    \label{fig:loesung4}
\end{figure}
Da auf Grund der Größe wenig zu erkennen ist.
Hier heran gezoomt.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{solution_4_zoomed.pdf}
    \caption{Losung des BWinfs Stromrallye Spiels Beispiel 4 heran gezoomt}
    \label{fig:loesung4_zoomed}
\end{figure}


\section{Quellen}

\printbibheading
\printbibliography[omitnumbers=false,type=online,heading=subbibliography,title={Digital}]

%\subsection{Bücher}
%\newcommand{\addReference}[2]{\hspace{-25pt}[#1]\hspace{10pt} #2\par}
%\addReference{Ein25}{Einstein 2025 "Laura ist cool" S 5-8}
%\hspace{-10pt}\addReference{Ble20}{Laura Blechschmidt 2020 "Die Mikrowelle die Krebs heilt"  }

%\defbibenvironment{nolabelbib}
%  {\list
%     {[Ble20]}
%     {\setlength{\leftmargin}{\bibhang}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\itemsep}{\bibitemsep}%
%      \setlength{\parsep}{\bibparsep}}
%      }
%  {\endlist}
%  {\item}
  
\printbibliography[nottype=online, heading=subbibliography, title=Bücher]



\section{Erklärung über die selbständige Anfertigung der Arbeit}
Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und ohne fremde Hilfe verfasst, alle aus anderen Werken wörtlich oder sinngemäß entnommenen Stellen und Abbildungen unter Angabe der Quelle als Entlehnung kenntlich gemacht und keine anderen Hilfsmittel als die angegebenen verwendet habe. \\
\Ort, \today \space \Name


\end{document}
